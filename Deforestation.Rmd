---
title: "Deforestation Learning Module"
output: 
  html_document:
      toc: true
      toc_float: true
      number_sections: true
---
```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, cache = TRUE)
knitr::opts_knit$set(root.dir = '/Users/shanchao/Desktop/Davis/Quarters/2021 III/CEGA intern/Module/Learning Module') # change working directory to local
```
# INTRODUCTION 

## Introduction to Remote Sensing
This section is adopted from the module 1, section 1 of [Open Nighttime Lights](https://worldbank.github.io/OpenNightLights/tutorials/mod1_1_introduction_to_remote_sensing.html). Please refer to it for more details and a video introduction of remote sensing.

**Remote sensing** is the science of identifying, observing, collecting and measuring objects without coming into direct contact with them. This can be accomplished through many devices that carry sensors and capture the characteristics of Earth remotely. Sensors on board satellites also record the electromagnetic energy that is reflected or emitted from objects on Earth. There are two types of sensors:

* **Passive sensors** record the natural energy that is (naturally) reflected or emitted from the Earth's surface (e.g. sunlight, moonlight, city lights).
* **Active sensors** provide their own energy source for illumination (e.g. RADAR, LIDAR).

## Introduction to Forest Cover Data
In this exercise, we will primarily work on the [Vegetation Continuous Fields](https://lpdaac.usgs.gov/products/mod44bv006/) (VCF) provided by. The MOD44B Version 6 VCF is an annual data from 2000 to 2020 at 250 m resolution. Each pixel stores percentage of ground cover components. Three components of ground cover: percent tree cover, percent non-tree vegetation and percent bare, are included in separate layers. 

The percents of ground cover are estimates from a machine learning model based on the combination of the Moderate Resolution Imaging Spectroradiometer ([MODIS](https://modis.gsfc.nasa.gov/)) data and other high resolution data from NASA and Google Earth. The machine learning model incorporates not only the visible bandwidth but other bandwidth such as brightness temperature (from MODIS bands 20, 31, 32). 

The VCF data utilizes thermal signatures and other correlates to distinguish forest and non-forest plantation, which is an improvement compared to the Normalized Differenced Vegetation Index (NDVI). The Global Forest Cover (GFC) data set also describes deforestation but in a binary fashion. It records baseline forest cover in the year 2000 and includes a binary indicator for the year of deforestation for each 30m Ã— 30m pixel. If over 90% of the forest cover was lost in a pixel by a given year, then the pixel will be marked as deforested, or reforested if the forest cover went from 0 in 2000 to positive. The VCF provide continuous percentage changes in percents of ground components cover which provides more details than the GFC data.   

# INTRODUCTION TO GEOSPATIAL DATA AND TOOLS

## Data Structure
In geospatial data analysis, data can be classified into two categories: raster and vector data. A graphic comparison between raster and vector data can be found in [this](https://worldbank.github.io/OpenNightLights/tutorials/mod2_1_data_overview.html) page.

* **Raster data**: Data stored in a raster format is arranged in a regular grid of cells, without storing the coordinates of each point (namely, a cell, or a pixel). The coordinates of the corner points and the spacing of the grid can be used to calculate (rather than to store) the coordinates of each location in the grid. Any given pixel in the grid stores one or more values (in one or more bands).
* **Vector data**: Data in a vector format is stored in a way that the X and Y coordinates are stored for each point. Data can be represented, for example, as points, lines and polygons. A point has only one coordinate (X and Y), a line has two coordinates (at the start and end of the line) and an area is essentially a line that closes on itself to enclose a region. Polygons are usually used to represent the area and perimeter of a continuous geographic features. Vector data stores features in their original resolution, without aggregation.

In this tutorial, we will use both vector data and raster data. Geospatial data in vector format are often stored in a **shapefile** format. Because the structure of points, lines, and polygons are different, each individual shapefile can only contain one vector type (all points, all lines or all polygons). You will not find a mixture of point, line and polygon objects in a single shapefile. Raster data, on the other hand, is stored in **Tagged Image File Format (TIFF or TIF)**. A GeoTIFF is a TIFF file that follows a specific standard for structuring meta-data. The meta-data stored in a TIFF is called a tif tag and GeoTIFFs often contain tags including: spatial extent, coordinate reference system, resolution, and number of layers. We will see examples in section 2.2. 

More information and examples can be found in section 3 & 4 of the [Earth Analytics Course](https://www.earthdatascience.org/courses/earth-analytics/). 

## Tools

### Installation of R
To get started with R, we provide instructions on how to download and install R on your end. R is an open source software, which means users like you can also inspect, modify and improve its source code.

The Comprehensive R Archive Network ([CRAN](https://cran.r-project.org/)) provides links to install R under different operating systems. RStudio [page](https://support.rstudio.com/hc/en-us/articles/200554786-Problem-Installing-Packages) provides a brief guide for troubleshooting. 

### RStudio
RStudio is an integrated development environment for R. We can think R provides the engine for running codes, and RStudio is a user friendly control panel to perform various tasks. RStudio facilitates R codes writing, debugging and provides tools for workspace management. RStudio can be downloaded from the RStudio [IDE page](https://www.rstudio.com/products/rstudio/download/). 

There are numerous posts, tutorials, courses on the internet. Once you have installed R and RStudio, pick any of the following resource to get familiar with R:

* Online courses
  + Datacamp online course: [Introduction to R](https://www.datacamp.com/courses/free-introduction-to-r)
  + Coursera collaborated with Johns Hopkins University provides an online course on [R programming](https://www.coursera.org/learn/r-programming)

* Books
  + [R Cookbook 2nd Edition](https://rc2e.com/) by James Long and Paul Teetor
  + [R for Data Science](https://r4ds.had.co.nz/) by Hadley Wickham and Garrett Grolemund

### Setting up Environment

In order to perform data manipulation, we need to attach packages. The first step is downloading R packages from CRAN. For this exercise, we are going to use package _luna_ and to download data from MODIS, and use _terra_, _tidyverse_, _raster_ and _sf_ for data manipulation. To do this, in R or RStudio console, type the following code (you will need the _remotes_ package in order to download _luna_):
```{r install, eval=FALSE, include=TRUE}
install.packages(c("terra", "remotes", "tidyverse", "raster", "sf"))
remotes::install_github("rspatial/luna")
```
We follow [this](https://rspatial.org/terra/modis/index.html) tutorial to get MODIS data by _luna_. For details of the _terra_ package, please refer to the [package manuscript](https://cran.r-project.org/web/packages/terra/terra.pdf) and [this](https://rspatial.org/terra/pkg/index.html#) tutorial. If you are not familiar with the _tidyverse_ workflow, please refer to [R for Data Science](https://r4ds.had.co.nz/) that we suggested in the previous section. We now attach these packages.  
```{r, message=FALSE}
library(terra)
library(luna)
library(tidyverse)
library(raster)
library(sf)
```

### Accessing VCF in R

Once packages have been attached, we can access VCF in R. This [website](https://modis.gsfc.nasa.gov/tools/) in NASA has various tools to access _MODIS_ data, but these tools are not ideal for downloading large number of files or keeping data up-to-date automatically. 

We can check the list of data products on _MODIS_. Since _luna_ can also access data from _LANDSAT_ and _SENTINEL_ platforms, we add `"^MOD|^MYD|^MCD"` to narrow our scope to _MODIS_ data. The printed results below listed six products from _MODIS_. 
```{r}
MODIS.product = getProducts("^MOD|^MYD|^MCD")
head(MODIS.product)
```
The product name for VCF is _MOD44B_. We can use function `productInfo` to launch the information page of VCF. 
```{r, eval=FALSE}
productInfo("MOD44B")
```
We can query _MODIS_ and only download subset of the data. We need to specify start and end dates, and area of interest (AOI). The date format is "yyyy-mm-dd". Suppose here we want to subset data from 2010 to 2012.
```{r}
start.date = "2010-01-01"
end.date   = "2012-12-31"
```
In order to subset your area of interest, you need to provide a "map" to `getModis()`. This can be obtained from online databases. One example is from the global administrative area database ([GADM](https://gadm.org/index.html)). You can download map data directly from GADM like in this [post](https://keithnewman.co.uk/r/maps-in-r-using-gadm.html). Or you can use R to obtain data. To do this, you need to install package `geodata`. 
```{r, eval=F}
remotes::install_github("rspatial/geodata")
```
For example, we are interested in India and its administrative areas, we can download India and its administrative area boundaries by

```{r, eval=F}
india = geodata::gadm("India", level=2, path=".")
```
The boundary data is then downloaded to the path that you specified in the `path` argument. The downloaded data through `gadm()` will be in the _PackedSpatVector_ class. If you want to convert it to other class (for example, _sf_ class), you can first read it using `readRDS()`, then create _SpatVector_ via `vect()` in the _terra_ package, and finally convert it to a _sf_ object.
```{r}
india = readRDS("./data/gadm36_IND_2_pk.rds") %>% vect() %>% st_as_sf(india)
```
Notice that levels in GADM are defined as:

* level 0: National
* level 1: State/province/equivalent
* level 2: County/district/equivalent
* level 3/4: Smaller administrative levels

The map we download is at the district level. Assume our AOI is the Odisha state. `aoi` is in vector format and is stored in as a data frame in R. Each row of the data represents a county in Odisha state. The geospatial information for each county is stored in the last column `geometry`.

```{r}
aoi = india %>% filter(NAME_1 == "Odisha")
head(aoi)
ggplot(data = aoi) +
  geom_sf()
```

We now have time range and AOI ready, we can check what _MODIS_ has for VCF. 
```{r}
vcf.files = getModis("MOD44B", start.date, end.date, aoi, download = F)
head(vcf.files)
```
The products we are going to download are tiled products. For details of tiled product and the tilling system, please refer to _MODIS_ overview page [here](https://lpdaac.usgs.gov/data/get-started-data/collection-overview/missions/modis-overview/#modis-tiling-systems). We will basically download grids of maps that cover our AOI. The naming convention is also explained in the overview page. 

To download these files, you can use the following code,
```{r, eval=F}
getModis("MOD44B", start.date, end.date, aoi, download = T, path = YourPathHere,  username = YourNASAUserName, password = YourPassWord)
```
You will need user name and password to interact with the NASA server. Please register on [NASA Earth Data](https://urs.earthdata.nasa.gov/) if you haven't done so. 
```{r, include = F, eval = F}
getModis("MOD44B", start.date, end.date, aoi, download = T, path = "/Users/shanchao/Desktop/Davis/Quarters/2021 III/CEGA intern/Module/Learning Module/data/VCFexample",  username = "wscwang", password = "CEGA2021Intern")
```
The data format from _MODIS_ is HDF that may include sub-datasets. We can use `terra` to read these files and create raster files. For example,
```{r, warning=F}
hdf.example = rast("./data/VCFexample/MOD44B.A2009065.h25v06.006.2017081034537.hdf")
hdf.example
```
We can find basic information such as coordinate reference system, number of cells, resolution from the above output. There are `r length(names(hdf.example))` layers in each of the VCF tiled file. We are interested in the percent tree coverage. 
```{r}
names(hdf.example)
```
A quick plot of the data can be done with the `plotRBG()` function. We will dive into data processing and basic operations in the next section.
```{r}
plotRGB(hdf.example, stretch = "lin")
```

# BASIC OPERATIONS
In this section, we will follow [this](https://tmieno2.github.io/R-as-GIS-for-Economists/before-you-start-3.html) tutorial to process data that we have downloaded from _MODIS_. Note that _terra_ is a relatively new package, although it is maintained frequently, a lot of other packages have not yet adopted _terra_ objects (i.e. `SpatRaster`). Hence, we sometimes will use _raster_ package to process data. 

In previous section, we know that VCF data has `r length(names(hdf.example))` layers. If we directly convert `SpatRaster` to `RasterLayer`, it will only convert the first layer by default. For discussion of different class of `raster`, please see section 4.1 of the _R as GIS for Economist_ page listed above. 

## Merging, cropping and masking

Since there are four hdf files in each year for our AOI, let's first merge four `SpatRaster` files into one in a year, say 2010. We only read the first layer (percent of tree cover) of each hdf file, which can be done by subset the output using `[[1]]`.  

```{r}
# getting file names and directories
vcf.files.2010 = paste0("./data/VCFexample/", vcf.files[grep("A2010065", vcf.files)])

# read hdf files as SpatRaster
vcf.raster.2010 = lapply(vcf.files.2010, function(x) rast(x)[[1]])
```
Before we merge these `SpatRster`, it is often a good practice to check origin and resolution of them. `merge` requires origin and resolution to be the same across objects.

```{r}
lapply(vcf.raster.2010, res)
lapply(vcf.raster.2010, origin)
```
Note that origins of these files are slightly different but all close to (0, 0). We do not need to worry about it, as `merge` will handle it automatically.
```{r}
vcf.raster.2010 = do.call(merge, vcf.raster.2010)
plot(vcf.raster.2010)
```

We are now ready to crop and mask the raster file given our AOI. [This](http://132.72.155.230:3838/r/combining-rasters-and-vector-layers.html) tutorial explains the difference between cropping and masking. 

To crop a raster file given a vector data, first match the coordinate reference systems of raster file and vector file. Then use `crop(raster data, vector data)`. To mask, use `mask(raster data, vector data)`. Note that for `terra::mask()`, the second argument need to be `SpatVector`. _terra_ does not support `sf` objects yet. 
```{r}
# align coordinate reference systems
aoi = aoi %>% st_transform(crs = crs(vcf.raster.2010))

# crop raster data
vcf.raster.2010.aoi = terra::crop(vcf.raster.2010, aoi)

# mask raster data
vcf.raster.2010.aoi = mask(vcf.raster.2010.aoi, vect(aoi))
```
To plot your new raster file with boundaries, we do the following
```{r}
plot(vcf.raster.2010.aoi)
plot(st_geometry(aoi), add = TRUE)
```

## Extracting values and computing statistics
After we have crop and mask the raster file to our AOI, we can extract values for each county in the state of Odisha. For instructions of extracting values for points, please refer to section [5.2](https://tmieno2.github.io/R-as-GIS-for-Economists/extracting-values-from-raster-layers-for-vector-data.html) in _R as GIS for Economist_.

```{r}
# extract values for each county
aoi.county.vcf = terra::extract(vcf.raster.2010.aoi, vect(aoi))
colnames(aoi.county.vcf) = c("ID", "Percent Tree Cover")
head(aoi.county.vcf)
```
The values extracted by `terra::extract` here is stored as a data frame. Note that the `ID` corresponds to row number of your vector file (i.e. object `aoi` in our case). We can then compute statistics based on this data frame. Here I compute several statistics of percent of forest cover, such as mean, median, max, min, and percent of positive forest covered land, for each county. Note that cells with 200% represent water and river and should be excluded from calculation.
```{r}
aoi.summary = aoi.county.vcf %>% filter(`Percent Tree Cover` <= 100) %>%
  group_by(ID) %>%
  summarise(Mean    = mean(`Percent Tree Cover`),
            Median  = median(`Percent Tree Cover`),
            Max     = max(`Percent Tree Cover`),
            Min     = min(`Percent Tree Cover`),
            `Positive Percent` = sum(`Percent Tree Cover` > 0)/length(`Percent Tree Cover`) * 100)
aoi.summary = aoi.summary %>% mutate(ID = aoi$NAME_2) %>% rename(County = ID)
knitr::kable(aoi.summary, digits = 2)
```
## Storing and exporting results
With _terra_ you can easily write shape files and several formats of raster files. Main function for writing vector data is `writeVector()` and for writing raster data is `writeRaster()`. For details, you can refer to [this](https://rspatial.org/terra/spatial/5-files.html) page and the manuscript of _terra_.

# USAGE EXAMPLE

In this section, we will replicate some main results in the [paper](https://academic.oup.com/ej/article-abstract/130/629/1173/5798996?redirectedFrom=fulltext) _The Ecological Impact of Transportation Infrastructure_ by Sam Asher, Teevrat Garg and Paul Novosad in 2020. To access the full replication data and codes, check [this](https://github.com/devdatalab/paper-agn-forests-roads) github repo. We are going to replicate Table 3 in the paper.

The research question is whether new constructed rural roads have impacts on local deforestation. Authors used two empirical strategies: fuzzy RD and difference-in-difference. In the following sections, we implement the difference-in-difference method and replicate regression results.

## Preparation
### Packages
In order to run fixed effects models, we will need the `fixest` package. If you have not download it, you can type `install.packages("fixest")` in the R or RStudio console. 
```{r}
library(fixest)
```
[This](https://cran.r-project.org/web/packages/fixest/vignettes/fixest_walkthrough.html) tutorial is a good reference for introducing `fixest` functions.

### Data
Data for this exercise was processed and stored in `pmgsy_trees_rural_panel.csv`. Each row of the data frame presents a village in a specific year. 
```{r, eval=F}
rural.data = data.table::fread("./data/pmgsy_trees_rural_panel.csv")
```
```{r, include=F}
rural.data = data.table::fread("/Users/shanchao/Desktop/Davis/Quarters/2021 III/CEGA intern/Module/Learning Module/data/agn-roads-forests-data-csv/pmgsy_trees_rural_panel.csv")
```

## Replication
The paper estimated the following equation:
$$
Forest_{vdt} = \beta_1\cdot Award_{vdt} + \beta_2\cdot Complete_{vdt} + \alpha_v + \gamma_{dt} + X_v\cdot V_t + \eta_{vdt} 
$$
where $Forest_{vdt}$ is forest cover of village $v$ in district $d$ in year $t$. $Award_{vdt}$ is a dummy variable takes one during the period when the new road is awarded to the village but has not been built. $Complete_{vdt}$ is also a dummy variable takes one for all years following the completion of a new road to village $v$. $\alpha_v$ is village fixed effects, while $\gamma_{dt}$ is the district-year fixed effects. $X_v$ controls some baseline characteristics (e.g. forest cover in 2000, total population), and is interacted with year fixed effects $V_t$. For more details regarding the model specification, please refer to section 3.3 of the paper. 

The syntax is straightforward, we allow baseline forest cover and total population have varying slopes across years. Note that the paper clustered standard error at the village level. 

There is one more step before we run regressions. In Stata, `reghdfe` removed singleton groups automatically, but the `fixest` package has a problem with this (hopefully will be resolved soon). For now, we manually remove these observations.

```{r}
# detect singleton groups: check village fixed effects and district-year fixed effects
index = lapply(list(rural.data$svgroup, rural.data$sdygroup), function(x) x[!(x %in% x[duplicated(x)])])

# how many observations need to be dropped
lapply(index, function(x) length(x))

# exclude singleton groups
rural.data = rural.data %>% filter(!(sdygroup %in% index[[2]]))
```

The results align with what presented in table 3. The new constructed roads had zero impact on local deforestation.

```{r}
# Table 3
# Column (1)
log.forest.main = feols(ln_forest ~ award_only + treatment_comp|svgroup + sdygroup + year[ln_forest_2000, pc01_pca_tot_p], 
             cluster = "svgroup", 
             data = rural.data)
# Column (2)
log.forest.test = feols(ln_forest ~              treatment_comp|svgroup + sdygroup + year[ln_forest_2000, pc01_pca_tot_p], 
             cluster = "svgroup", 
             data = rural.data)
# Column (3)
avg.forest.main = feols(avg_forest ~ award_only + treatment_comp|svgroup + sdygroup + year[ln_forest_2000, pc01_pca_tot_p], 
             cluster = "svgroup", 
             data = rural.data)
# Column (4)
avg.forest.test = feols(avg_forest ~              treatment_comp|svgroup + sdygroup + year[avg_forest_2000, pc01_pca_tot_p], 
             cluster = "svgroup", 
             data = rural.data)
etable(log.forest.main, log.forest.test, avg.forest.main, avg.forest.test,
       signifCode = c("***"=0.01,"**"=0.05,"*"=0.10),
       drop.section = "slopes")
```